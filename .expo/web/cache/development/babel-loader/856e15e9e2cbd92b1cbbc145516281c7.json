{"ast":null,"code":"var comparePoints = function comparePoints(currentPosition, target) {\n  var x = target.long - currentPosition.long;\n  var y = target.lat - currentPosition.lat;\n  var quadrantX = x > 0 ? 'E' : 'W';\n  var quadrantY = y > 0 ? 'N' : 'S';\n  var quadrant = getQuadrant(quadrantX, quadrantY);\n  var angle = calculateAngle(quadrant, x, y);\n  return angle;\n};\n\nvar getQuadrant = function getQuadrant(x, y) {\n  if (x === 'E' && y === 'N') return 0;\n  if (x === 'E' && y === 'S') return 1;\n  if (x === 'W' && y === 'S') return 2;\n  return 3;\n};\n\nvar calculateAngle = function calculateAngle(quadrant, x, y) {\n  var angle = Math.atan2(Math.abs(x), Math.abs(y)) * 180 / Math.PI;\n  if (quadrant === 1) return 180 - angle;\n  if (quadrant === 2) return 180 + angle;\n  if (quadrant === 3) return 360 - angle;\n  return angle;\n};\n\nvar getAngle = function getAngle(magnetometer) {\n  if (magnetometer) {\n    var x = magnetometer.x,\n        y = magnetometer.y;\n    var angleRad = Math.atan2(y, x);\n    return angleRad >= 0 ? angleRad * 180 / Math.PI : (angleRad + 2 * Math.PI) * 180 / Math.PI;\n  }\n\n  return 0;\n};\n\nvar getDegree = function getDegree(angle) {\n  return angle - 90 >= 0 ? angle - 90 : angle + 271;\n};\n\nvar getDirection = function getDirection(degree) {\n  if (degree >= 22.5 && degree < 67.5) {\n    return \"NE\";\n  } else if (degree >= 67.5 && degree < 112.5) {\n    return \"E\";\n  } else if (degree >= 112.5 && degree < 157.5) {\n    return \"SE\";\n  } else if (degree >= 157.5 && degree < 202.5) {\n    return \"S\";\n  } else if (degree >= 202.5 && degree < 247.5) {\n    return \"SW\";\n  } else if (degree >= 247.5 && degree < 292.5) {\n    return \"W\";\n  } else if (degree >= 292.5 && degree < 337.5) {\n    return \"NW\";\n  } else {\n    return \"N\";\n  }\n};\n\nvar findAngleMatch = function findAngleMatch(myAngle, dataset, currentPosition) {\n  var matches = [];\n  var ANGLE_THRESHOLD = 5.0;\n  Object.keys(dataset).forEach(function (peak) {\n    var superPeak = {\n      lat: dataset[peak].Latitude,\n      long: dataset[peak].Longitude\n    };\n    var angle = comparePoints(currentPosition, superPeak);\n    var min = angle < ANGLE_THRESHOLD ? 0 : angle - ANGLE_THRESHOLD;\n    var max = angle + ANGLE_THRESHOLD;\n    if (myAngle > min && myAngle < max) matches.push(peak);\n  });\n  return matches;\n};\n\nvar calculateDistanceBetweenAB = function calculateDistanceBetweenAB(pointA, pointB) {\n  var EARTH_RADIUS = 6371;\n  var latPointA = pointA.lat * Math.PI / 180;\n  var latPointB = pointB.lat * Math.PI / 180;\n  var dLat = (pointB.lat - pointA.lat) * Math.PI / 180;\n  var dLong = (pointB.long - pointA.long) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(latPointA) * Math.cos(latPointB) * Math.sin(dLong / 2) * Math.sin(dLong / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return EARTH_RADIUS * c;\n};\n\nexport { comparePoints, getQuadrant, calculateAngle, getAngle, getDegree, getDirection, findAngleMatch, calculateDistanceBetweenAB };","map":{"version":3,"sources":["/Users/lepetitpifa/Documents/_git/PinPeak/src/utils/calculations.ts"],"names":["comparePoints","currentPosition","target","x","long","y","lat","quadrantX","quadrantY","quadrant","getQuadrant","angle","calculateAngle","Math","atan2","abs","PI","getAngle","magnetometer","angleRad","getDegree","getDirection","degree","findAngleMatch","myAngle","dataset","matches","ANGLE_THRESHOLD","Object","keys","forEach","peak","superPeak","Latitude","Longitude","min","max","push","calculateDistanceBetweenAB","pointA","pointB","EARTH_RADIUS","latPointA","latPointB","dLat","dLong","a","sin","cos","c","sqrt"],"mappings":"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","sourcesContent":["import LPF from 'lpf';\n\ninterface ICoordinates {\n  long: number;\n  lat: number;\n}\n\ninterface ICompass {\n  x: number;\n  y: number;\n  z: number;\n}\n\ninterface IPeakDataSet {\n  [key: string] : ICoordinates\n}\n\ninterface ISuperCoordinates {\n  \"Rank\": number;\n  \"Category Rank\": number;\n  \"Elevation\": number;\n  \"Range\": string;\n  \"Latitude\": number;\n  \"Longitude\": number;\n}\n\ninterface IPeaks {\n  [key: string]: ISuperCoordinates\n}\n\nconst comparePoints = (currentPosition: ICoordinates, target: ICoordinates) => {\n  const x = target.long - currentPosition.long;\n  const y = target.lat - currentPosition.lat;\n\n  // TODO: what if it is exactly 0?\n  const quadrantX = x > 0 ? 'E' : 'W';\n  const quadrantY = y > 0 ? 'N' : 'S';\n\n  const quadrant = getQuadrant(quadrantX, quadrantY);\n  const angle = calculateAngle(quadrant, x, y);\n\n  return angle;\n};\n\nconst getQuadrant = (x: string, y: string) => {\n  if (x === 'E' && y === 'N') return 0;\n  if (x === 'E' && y === 'S') return 1;\n  if (x === 'W' && y === 'S') return 2;\n  \n  return 3;\n};\n\nconst calculateAngle = (quadrant: number, x: number, y: number) => {\n  const angle = (Math.atan2(Math.abs(x), Math.abs(y))) * 180 / Math.PI;\n\n  if (quadrant === 1) return 180 - angle;\n  if (quadrant === 2) return 180 + angle;\n  if (quadrant === 3) return 360 - angle;\n  \n  return angle;\n};\n\nconst getAngle = (magnetometer: ICompass) => {\n  if (magnetometer) {\n    const {x, y} = magnetometer;\n    const angleRad = Math.atan2(y, x);\n    \n    return angleRad >= 0\n      ? (angleRad * 180 / Math.PI)\n      : ((angleRad + (2 * Math.PI)) * 180 / Math.PI);\n  }\n\n  // return Math.round(LPF.next(angle))\n  return 0;\n};\n\n// Match the device top with pointer 0° degree. (By default 0° starts from the right of the device.)\nconst getDegree = (angle: number) => {\n  return angle - 90 >= 0\n    ? angle - 90\n    : angle + 271;\n};\n\nconst getDirection = (degree: number) => {\n  if (degree >= 22.5 && degree < 67.5) {\n    return \"NE\";\n  } else if (degree >= 67.5 && degree < 112.5) {\n    return \"E\";\n  } else if (degree >= 112.5 && degree < 157.5) {\n    return \"SE\";\n  } else if (degree >= 157.5 && degree < 202.5) {\n    return \"S\";\n  } else if (degree >= 202.5 && degree < 247.5) {\n    return \"SW\";\n  } else if (degree >= 247.5 && degree < 292.5) {\n    return \"W\";\n  } else if (degree >= 292.5 && degree < 337.5) {\n    return \"NW\";\n  } else {\n    return \"N\";\n  }\n};\n\nconst findAngleMatch = (myAngle: number, dataset: IPeaks, currentPosition: ICoordinates) => {\n  const matches = [];\n  const ANGLE_THRESHOLD = 5.0;\n\n  Object.keys(dataset).forEach(peak => {\n    const superPeak = { lat: dataset[peak].Latitude, long: dataset[peak].Longitude };\n    const angle = comparePoints(currentPosition, superPeak);\n    const min = angle < ANGLE_THRESHOLD ? 0 : angle - ANGLE_THRESHOLD;\n    const max = angle + ANGLE_THRESHOLD;\n    if (myAngle > min && myAngle < max) matches.push(peak);\n  });\n\n  return matches;\n}\n\nconst calculateDistanceBetweenAB = (pointA: ICoordinates, pointB: ICoordinates): number => {\n  // This uses the ‘haversine’ formula to calculate the great-circle distance between two points \n  // – that is, the shortest distance over the earth’s surface – giving an ‘as-the-crow-flies’ \n  // distance between the points (ignoring any hills they fly over)\n  // https://www.movable-type.co.uk/scripts/latlong.html\n  const EARTH_RADIUS = 6371; // in Kilometers\n  const latPointA = pointA.lat * Math.PI / 180;\n  const latPointB = pointB.lat * Math.PI / 180;\n\n  const dLat = (pointB.lat - pointA.lat) * Math.PI / 180;\n  const dLong = (pointB.long - pointA.long) * Math.PI / 180;\n\n  const a = (Math.sin(dLat / 2) * Math.sin(dLat / 2)) + (Math.cos(latPointA) * Math.cos(latPointB) * Math.sin(dLong / 2) * Math.sin(dLong / 2));\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n  return EARTH_RADIUS * c;\n}\n\nexport { comparePoints, getQuadrant, calculateAngle, getAngle, getDegree, getDirection, findAngleMatch, calculateDistanceBetweenAB };"]},"metadata":{},"sourceType":"module"}
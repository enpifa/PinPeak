{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"/Users/lepetitpifa/Documents/_git/PinPeak/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Button from \"react-native-web/dist/exports/Button\";\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { Magnetometer } from 'expo-sensors';\nimport LPF from 'lpf';\nimport listOfPeaks from \"./ListOfPeaks.json\";\nimport peakDB from \"./constants/peakDB\";\nimport { comparePoints, getAngle, getDegree, getDirection, findAngleMatch, calculateDistanceBetweenAB } from \"./utils/calculations\";\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  helloMessage: {\n    fontSize: 20\n  }\n});\nexport default function App() {\n  var initialCompass = {\n    x: null,\n    y: null,\n    z: null\n  };\n  var initialCoords = {\n    lat: null,\n    long: null\n  };\n\n  var _useState = useState(initialCompass),\n      _useState2 = _slicedToArray(_useState, 2),\n      compass = _useState2[0],\n      setCompass = _useState2[1];\n\n  var _useState3 = useState(initialCoords),\n      _useState4 = _slicedToArray(_useState3, 2),\n      coords = _useState4[0],\n      setCoords = _useState4[1];\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      face = _useState6[0],\n      setFace = _useState6[1];\n\n  var _useState7 = useState([]),\n      _useState8 = _slicedToArray(_useState7, 2),\n      target = _useState8[0],\n      setTarget = _useState8[1];\n\n  var updateCount = 0;\n  var partialCompass = {\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  useEffect(function () {\n    LPF.init([]);\n    LPF.smoothing = 0.4;\n    Magnetometer.removeAllListeners();\n    setCompass(initialCompass);\n    setCoords(initialCoords);\n    setFace(null);\n    findCoordinates();\n    findXYZ();\n  }, []);\n\n  var findCoordinates = function findCoordinates() {\n    navigator.geolocation.getCurrentPosition(function (position) {\n      var coords = {\n        lat: position.coords.latitude,\n        long: position.coords.longitude\n      };\n      setCoords(coords);\n    }, function (error) {\n      return Alert.alert(error.message);\n    }, {\n      enableHighAccuracy: true,\n      timeout: 20000,\n      maximumAge: 1000\n    });\n  };\n\n  var findXYZ = function findXYZ() {\n    Magnetometer.setUpdateInterval(40);\n    Magnetometer.addListener(function (xyz) {\n      if (updateCount === 7) {\n        updateCount = 0;\n        var newCompass = {\n          x: partialCompass.x / 5,\n          y: partialCompass.y / 5,\n          z: partialCompass.z / 5\n        };\n        setCompass(newCompass);\n        var newAngle = Math.round(LPF.next(getAngle(newCompass)));\n        var newDegree = getDegree(newAngle);\n        setFace(newDegree);\n        var matches = findAngleMatch(newDegree, listOfPeaks, coords);\n        setTarget(matches);\n        partialCompass = {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      } else {\n        updateCount += 1;\n        partialCompass.x += xyz.x;\n        partialCompass.y += xyz.y;\n        partialCompass.z += xyz.z;\n      }\n    });\n  };\n\n  var getFace = function getFace() {\n    var newAngle = getAngle(compass);\n    var newDegree = getDegree(newAngle);\n    var newDirection = getDirection(newDegree);\n    return newDirection;\n  };\n\n  var mockMatch = findAngleMatch(191.0, listOfPeaks, {\n    lat: 39.798,\n    long: -105.074\n  });\n  return React.createElement(View, {\n    style: styles.container,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 5\n    }\n  }, coords.lat !== null ? React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 31\n    }\n  }, \"Your position i$$ [ \", coords.lat, \", \", coords.long, \" ]\") : null, React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 7\n    }\n  }, \"You are facing [ \", getFace(), \" , angle: \", face, \" ]\"), React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 7\n    }\n  }, \"#Matches: \", target.length), target.length !== 0 ? target.map(function (match) {\n    var key = \"match-\" + match;\n    var matchCoords = {\n      lat: listOfPeaks[match].Latitude,\n      long: listOfPeaks[match].Longitude\n    };\n    var distance = calculateDistanceBetweenAB(coords, matchCoords);\n    return React.createElement(Text, {\n      key: key,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 110,\n        columnNumber: 18\n      }\n    }, match, \" / distance: \", distance.toFixed(3), \" / angle: \", comparePoints(coords, matchCoords).toFixed(4));\n  }) : null);\n}","map":{"version":3,"sources":["/Users/lepetitpifa/Documents/_git/PinPeak/src/App.js"],"names":["React","useState","useEffect","Magnetometer","LPF","listOfPeaks","peakDB","comparePoints","getAngle","getDegree","getDirection","findAngleMatch","calculateDistanceBetweenAB","styles","StyleSheet","create","container","flex","backgroundColor","alignItems","justifyContent","helloMessage","fontSize","App","initialCompass","x","y","z","initialCoords","lat","long","compass","setCompass","coords","setCoords","face","setFace","target","setTarget","updateCount","partialCompass","init","smoothing","removeAllListeners","findCoordinates","findXYZ","navigator","geolocation","getCurrentPosition","position","latitude","longitude","error","Alert","alert","message","enableHighAccuracy","timeout","maximumAge","setUpdateInterval","addListener","xyz","newCompass","newAngle","Math","round","next","newDegree","matches","getFace","newDirection","mockMatch","length","map","match","key","matchCoords","Latitude","Longitude","distance","toFixed"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { StyleSheet, Text, View, Button, Alert } from 'react-native';\nimport { Magnetometer } from 'expo-sensors';\nimport LPF from 'lpf';\nimport listOfPeaks from './ListOfPeaks.json';\n\nimport peakDB from './constants/peakDB';\nimport { comparePoints, getAngle, getDegree, getDirection, findAngleMatch, calculateDistanceBetweenAB } from './utils/calculations';\n// import {magnetometer, SensorTypes, setUpdateIntervalForType} from \"react-native-sensors\";\n// import Geolocation from '@react-native-community/geolocation';\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  helloMessage: {\n    fontSize: 20\n  }\n});\n\n// NOTE: latitude refers to N/S, which corresponds to the Y axis\n// the same way, longitude refers to E/W, which corresponds to the X axis\n\nexport default function App() {\n  const initialCompass = {x: null, y: null, z: null};\n  const initialCoords = {lat: null, long: null};\n  const [compass, setCompass] = useState(initialCompass);\n  const [coords, setCoords] = useState(initialCoords);\n  const [face, setFace] = useState(null);\n  const [target, setTarget] = useState([]);\n  let updateCount = 0;\n  let partialCompass = { x: 0, y: 0, z: 0 };\n\n  useEffect(() => {\n    LPF.init([]);\n    LPF.smoothing = 0.4;\n    Magnetometer.removeAllListeners();\n    setCompass(initialCompass);\n    setCoords(initialCoords);\n    setFace(null);\n    findCoordinates();\n    findXYZ();\n  }, []);\n  \n  const findCoordinates = () => {\n    navigator.geolocation.getCurrentPosition(\n      position => {\n        const coords = { lat: position.coords.latitude, long: position.coords.longitude };\n        setCoords(coords);\n      },\n      error => Alert.alert(error.message),\n      { enableHighAccuracy: true, timeout: 20000, maximumAge: 1000 }\n    );\n  };\n      \n  const findXYZ = () => {\n    Magnetometer.setUpdateInterval(40);\n    Magnetometer.addListener(xyz => {\n      if (updateCount === 7) {\n        updateCount = 0;\n        const newCompass = { x: partialCompass.x / 5, y: partialCompass.y / 5, z: partialCompass.z / 5 };\n        setCompass(newCompass);\n        const newAngle = Math.round(LPF.next(getAngle(newCompass)));\n        const newDegree = getDegree(newAngle);\n        setFace(newDegree);\n  \n        const matches = findAngleMatch(newDegree, listOfPeaks, coords);\n        setTarget(matches);\n        partialCompass = { x: 0, y: 0, z: 0 };\n      }\n      else {\n        updateCount += 1\n        partialCompass.x += xyz.x;\n        partialCompass.y += xyz.y;\n        partialCompass.z += xyz.z;\n      }\n    });\n    // Magnetometer.removeAllListeners();\n  }\n\n  const getFace = () => {\n    const newAngle = getAngle(compass);\n    const newDegree = getDegree(newAngle);\n    const newDirection = getDirection(newDegree);\n\n    return newDirection;\n\n    // const matches = findAngleMatch(newDegree, peakDB, coords);\n    \n    // setTarget(matches);\n    // setFace(newDegree);\n  };\n\n  const mockMatch = findAngleMatch(191.0, listOfPeaks, {lat: 39.798, long: -105.074});\n      \n  return (\n    <View style={styles.container}>\n      {coords.lat !== null ? (<Text>Your position i$$ [ {coords.lat}, {coords.long} ]</Text>) : null}\n      {/* {compass.x !== null ? (<Text>[ {compass.x.toFixed(3)} | {compass.y.toFixed(3)} | {compass.z.toFixed(3)} ]</Text>) : null} */}\n      <Text>You are facing [ {getFace()} , angle: {face} ]</Text>\n      <Text>#Matches: {target.length}</Text>\n      {target.length !== 0 ? (\n        target.map(match => {\n          const key = `match-${match}`;\n          const matchCoords = { lat: listOfPeaks[match].Latitude, long: listOfPeaks[match].Longitude };\n          const distance = calculateDistanceBetweenAB(coords, matchCoords);\n          return <Text key={key}>{match} / distance: {distance.toFixed(3)} / angle: {comparePoints(coords, matchCoords).toFixed(4)}</Text>\n        })\n      ) : null}\n      {/* {coords.long !== null ? (\n        Object.keys(listOfPeaks).map(peak => {\n          const target = { lat: listOfPeaks[peak].Latitude, long: listOfPeaks[peak].Longitude };\n          return <Text key={peak}>{peak} => [angle]: {comparePoints(coords, target).toFixed(4)} / [distance]: {calculateDistanceBetweenAB(coords, target).toFixed(4)}</Text>\n        })\n      ) : null} */}\n      {/* <Button title=\"Get Coordinates\" onPress={findCoordinates} /> */}\n      {/* <Button title=\"Get XYZ\" onPress={findXYZ} /> */}\n      {/* <Button title=\"Where am I facing?\" onPress={getFace} /> */}\n    </View>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}